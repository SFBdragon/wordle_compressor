; Assemble using:
; - nasm -f bin -o decoder decoder.asm

; Arguments for executing the binary (does not validate, invalid args may segfault):
; - 5 ASCII digit octal index: Outputs the word at the index, or 'inval' if index is too big
; - 5 ASCII letter word: Outputs 'valid' if word exists, 'inval' if not

; Assembly is mostly generated by nightly rustc as of 2022-04-05
; from /decoder/main.rs with the necessary modifications to make
; it work. In order to save space, the ELF header has been created
; in-line. This is linux-only due to ELF format and syscall IDs,
; but these should be swappable to create a Windows/other version.


[bits 64]

vaddr   equ     0x08048000
        org     vaddr                               ; sets asm base address

; elf header
        db      0x7f,'ELF',2,1,1,0,0,0,0,0,0,0,0,0  ; e_ident
        dw      2                                   ; e_type
        dw      0x3e                                ; e_machine
        dd      1                                   ; e_version
        dq      _start                              ; e_entry
        dq      phdr - $$                           ; e_phoff
        dq      0                                   ; e_shoff
        dd      0                                   ; e_flags
        dw      64                                  ; e_ehsize
        dw      0x38                                ; e_phentsize
        dw      1                                   ; e_phnum
        dw      0x40                                ; e_shentsize
        dw      0                                   ; e_shnum
        dw      0                                   ; e_shstrndx

phdr:
        dd      1                                   ; p_type
        dd      7                                   ; p_flags
        dq      0                                   ; p_offset
        dq      vaddr                               ; p_vaddr
        dq      vaddr                               ; p_paddr
        dq      eof - vaddr                         ; p_filesz
        dq      eof - vaddr + win_len               ; p_memsz
        dq      0x1000                              ; p_align



_start:
        mov     rax, window                     ; window neeeds to be pre-set to all '}'
.WINSET:
        mov     byte [rax], '}'
        inc     rax
        cmp     rax, window + win_len
        jne     .WINSET

        pop     rcx                             ; pop off argc, argv[0], keep argv[1]
        pop     rcx                             ; as this is the first passed argument
        pop     rcx

        mov     al, byte [rcx]
        cmp     al, 96
        mov     qword [rsp + 48], rax
        jbe     .LBB0_2
        mov     bl, byte [rcx + 1]
        mov     bpl, byte [rcx + 2]
        mov     dl, byte [rcx + 3]
        mov     cl, byte [rcx + 4]
        jmp     .LBB0_3
.LBB0_2:
        lea     edx, [rax - 48]
        movzx   esi, dl
        shl     rsi, 12
        mov     bl, byte [rcx + 1]
        mov     dl, byte [rcx + 2]
        add     bl, -48
        movzx   ebp, bl
        shl     rbp, 9
        or      rbp, rsi
        add     dl, -48
        movzx   edx, dl
        shl     rdx, 6
        mov     bl, byte [rcx + 3]
        add     bl, -48
        movzx   ebx, bl
        shl     rbx, 3
        or      rbx, rdx
        or      rbx, rbp
        mov     cl, byte [rcx + 4]
        add     cl, -48
        mov     eax, ebx
        or      al, cl
        shr     rbx, 8
        shr     rbp, 16
        xor     ecx, ecx
        xor     edx, edx
.LBB0_3:
        mov     dword [rsp + 16], ecx
        movzx   ecx, cl
        shl     rcx, 32
        mov     dword [rsp + 20], edx
        movzx   edx, dl
        shl     rdx, 24
        or      rdx, rcx
        movzx   ecx, bpl
        shl     rcx, 16
        or      rcx, rdx
        movzx   edx, bl
        shl     rdx, 8
        or      rdx, rcx
        mov     byte [rsp + 7], al
        movzx   eax, al
        or      rax, rdx
        mov     qword [rsp + 56], rax
        mov     r14b, 97
        mov     r11b, 104
        xor     r9d, r9d
        mov     rdx, blob
        mov     rcx, huffman_tree
        mov     rdi, window
        xor     eax, eax
        mov     qword [rsp + 8], rax
        xor     esi, esi
        mov     byte [rsp + 6], 97
        xor     eax, eax
        mov     qword [rsp + 24], rax
        xor     r8d, r8d
        xor     r10d, r10d
        mov     qword [rsp + 40], rbx
        mov     qword [rsp + 32], rbp
.LBB0_4:
        mov     r15, r10
        xor     ebp, ebp
.LBB0_5:
        mov     rbx, r8
        shr     rbx, 3
        mov     eax, r8d
        and     al, 7
        inc     r8
        movzx   ebx, byte [rbx + rdx]
        movzx   eax, al
        bt      ebx, eax
        adc     rbp, 0
        mov     bl, byte [rbp + rcx]
        movzx   ebp, bl
        test    bl, bl
        jns     .LBB0_5
        cmp     bl, -126
        jne     .LBB0_10
        mov     rdx, qword [rsp + 24]
        mov     rax, rdx
        shr     rax, 3
        mov     rcx, lzss_matches
        movzx   ebp, word [rax + rcx]
        movzx   eax, byte [rax + rcx + 2]
        shl     rax, 16
        or      rax, rbp
        mov     ebp, edx
        and     bpl, 7
        shrx    rbx, rax, rbp
        mov     r12d, ebx
        shr     r12d, 11
        and     r12d, 7
        add     r12, 6
        mov     rbp, r12
        mov     r10, r15
        mov     rdx, qword [rsp + 48]
        mov     ecx, 2047
.LBB0_8:
        lea     eax, [r10 + rbx]
        and     rax, rcx
        mov     al, byte [rax + rdi]
        mov     byte [r10 + rdi], al
        inc     r10d
        and     r10, rcx
        dec     rbp
        jne     .LBB0_8
        add     qword [rsp + 24], 14
        mov     rbp, qword [rsp + 32]
        mov     rbx, qword [rsp + 40]
        jmp     .LBB0_11
.LBB0_10:
        neg     bl
        mov     byte [r15 + rdi], bl
        lea     r10d, [r15 + 1]
        and     r10d, 2047
        mov     r12d, 1
        mov     rbp, qword [rsp + 32]
        mov     rbx, qword [rsp + 40]
        mov     rdx, qword [rsp + 48]
.LBB0_11:
        mov     ecx, r11d
.LBB0_12:
        mov     eax, r15d
        and     eax, 2047
        mov     r13b, byte [rax + rdi]
        test    r9b, 1
        je      .LBB0_23
        lea     r11, [rsi + 1]
        cmp     dl, 96
        jbe     .LBB0_19
        xor     r9d, r9d
        mov     al, byte [rsp + 6]
        cmp     byte [rsp + 7], al
        jne     .LBB0_21
        cmp     bl, r14b
        jne     .LBB0_21
        cmp     bpl, cl
        jne     .LBB0_21
        mov     rax, qword [rsp + 8]
        cmp     byte [rsp + 20], al
        jne     .LBB0_21
        mov     rsi, r11
        cmp     byte [rsp + 16], r13b
        jne     .LBB0_22
        jmp     .LBB0_33
.LBB0_19:
        cmp     rsi, qword [rsp + 56]
        je      .LBB0_34
        xor     r9d, r9d
.LBB0_21:
        mov     rsi, r11
        jmp     .LBB0_22
.LBB0_23:
        cmp     r13b, 123
        je      .LBB0_27
        cmp     r13b, 124
        je      .LBB0_28
        cmp     r13b, 125
        jne     .LBB0_30
        inc     cl
        jmp     .LBB0_22
.LBB0_27:
        inc     byte [rsp + 6]
        mov     r14b, 97
        jmp     .LBB0_29
.LBB0_28:
        inc     r14b
.LBB0_29:
        mov     cl, 97
        jmp     .LBB0_22
.LBB0_30:
        mov     eax, r13d
        mov     qword [rsp + 8], rax
        mov     r9b, 1
.LBB0_22:
        inc     r15
        dec     r12
        jne     .LBB0_12
        mov     r11d, ecx
        cmp     rsi, 12947
        mov     rdx, blob
        mov     rcx, huffman_tree
        jne     .LBB0_4
        mov     rdi, failure_msg
        jmp     .LBB0_35
.LBB0_33:
        mov     rdi, success_msg
        jmp     .LBB0_35
.LBB0_34:
        lea     rdi, [rsp + 67]
        mov     al, byte [rsp + 6]
        mov     byte [rdi], al
        mov     byte [rdi + 1], r14b
        mov     byte [rdi + 2], cl
        mov     rax, qword [rsp + 8]
        mov     byte [rdi + 3], al
        mov     byte [rdi + 4], r13b
.LBB0_35:
        mov     esi, 5
        
        mov     rdx, rsi
        mov     rsi, rdi
        mov     rax, 1
        mov     rdi, 1
        syscall                                         ; output message
        mov     rax, 60
        mov     rdi, 101
        syscall                                         ; exit gracefully


success_msg:
        db      'valid'

failure_msg:
        db      'inval'

lzss_matches:
        incbin  "../../encoder/lzss_matches"

huffman_tree:
        db      18, 2, 14, 4, -101, 6, 8, -121, -107, 10, 12, -102, -119, -118,
        db      -125, 16, -116, -126, 28, 20, -115, 22, 24, -97, 26, -100, -117,
        db      -124, 40, 30, 36, 32, -111, 34, -112, -99, -114, 38, -109, -103,
        db      44, 42, -105, -108, -110, 46, 48, -104, 50, -98, 52, -122, -120,
        db      54, -106, 56, -123, -113
blob:
        incbin  "../../encoder/words_i3_lzss_he"

eof:

window:
win_len equ     1 << 11
